# basic setting
# interpreter for shell commands
set shell zsh
# set '-eu' options for shell commands
# These options are used to have safer shell commands. Option '-e' is used to
# exit on error and option '-u' is used to give error for unset variables.
# Option '-f' disables pathname expansion which can be useful when $f, $fs, and
# $fx variables contain names with '*' or '?' characters. However, this option
# is used selectively within individual commands as it can be limiting at
# times.
set shellopts '-euy'
# set internal field separator (IFS) to "\n" for shell commands
# This is useful to automatically split file names in $fs and $fx properly
# since default file separator used in these variables (i.e. 'filesep' option)
# is newline. You need to consider the values of these options and create your
# commands accordingly.
set ifs "\n"
# leave some space at the top and the bottom of the screen
set scrolloff 10
# Use the `dim` attribute instead of underline for the cursor in the preview pane
set cursorpreviewfmt "\033[7;2m"
set icons
set period 1
set cleaner '~/.config/lf/cleaner'
#set previewer '~/.config/lf/preview2.sh'
set drawbox
# "latest modified first"
set sortby time
set reverse

# define a custom 'open' command
# This command is called when current file is not a directory. You may want to
# use either file extensions and/or mime types here. Below uses an editor for
# text files and a file opener for the rest.
cmd open &{{
    case $(file --mime-type -Lb $f) in
        text/*) lf -remote "send $id \$$EDITOR \$fx";;
        *) for f in $fx; do $OPENER $f > /dev/null 2> /dev/null & done;;
    esac
}}
# open with custom application
cmd openwith %"$@" "$fx"

# create direactory
cmd mkdir $mkdir -p "$(echo $* | tr ' ' '\ ')"

# define a custom 'rename' command without prompt for overwrite
cmd bulk-rename ${{
    old="$(mktemp)"
    new="$(mktemp)"
    if [ -n "$fs" ]; then
        fs="$(basename -a $fs)"
    else
        fs="$(ls)"
    fi
    printf '%s\n' "$fs" >"$old"
    printf '%s\n' "$fs" >"$new"
    $EDITOR "$new"
    [ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit
    paste "$old" "$new" | while IFS= read -r names; do
        src="$(printf '%s' "$names" | cut -f1)"
        dst="$(printf '%s' "$names" | cut -f2)"
        if [ "$src" = "$dst" ] || [ -e "$dst" ]; then
            continue
        fi
        mv -- "$src" "$dst"
    done
    rm -- "$old" "$new"
    lf -remote "send $id unselect"
}}

#Combining fzf with ripgrep, you can interactively search in the contents of files under the current directory and select a file from the results:
cmd fzf_search ${{
    res="$( \
        RG_PREFIX="rg --column --line-number --no-heading --color=always \
            --smart-case "
        FZF_DEFAULT_COMMAND="$RG_PREFIX ''" \
            fzf --bind "change:reload:$RG_PREFIX {q} || true" \
            --ansi --layout=reverse --header 'Search in files' \
            | cut -d':' -f1
    )"
    [ ! -z "$res" ] && lf -remote "send $id select \"$res\""
}}

# charge U disk
cmd diskmount ${{
# Get the target volume
target_vol=$(lsblk | fzf --reverse | sed 's/^[^[:alnum:]]*//' | cut -d' ' -f1)
# Is it encrypted or something?
if [[ $(lsblk -o NAME,FSTYPE | sed 's/^[^[:alnum:]]*//' | grep "$target_vol" | awk '{print $2}') == "crypto_LUKS" ]]; then
	echo "Volume is encrypted"
	udisksctl unlock -b /dev/"$target_vol"
	list_mount
	exit 0
fi
# Is it internal?
if [[ $(lsblk -o NAME,RM | sed 's/^[^[:alnum:]]*//' | grep "$target_vol " | awk '{print $2}') -eq 1 ]]; then
	removable=true
else
	removable=false
fi
# Adjust to proper device path
if [[ -e /dev/"$target_vol" ]]; then
	target_vol="/dev/$target_vol"
elif [[ -e /dev/mapper/"$target_vol" ]]; then
	target_vol="/dev/mapper/$target_vol"
else
	echo "Something vent wrong, no such volume?"
fi
if $removable; then
	udisksctl mount -b "$target_vol"
	echo "Press Return to continue"
	read 
else
	echo "Input mountpoint:"

	read mountpoint
	
	while ! [[ -d "$mountpoint" ]]; do
		sudo mkdir -p "$mountpoint" ||\
		echo "$mountpoint is not a possible mountpoint.
Input new mountpoint:" && read mountpoint
	done
	sudo mount "$target_vol" "$mountpoint" && \
	echo "Mounted $target_vol to $mountpoint
Press Return to continue"
read
fi
}}

# Trash cli bindings
cmd trash ${{
  files=$(printf "$fx" | tr '\n' ';')
  while [ "$files" ]; do
    # extract the substring from start of string up to delimiter.
    # this is the first "element" of the string.
    file=${files%%;*}

    trash-put "$(basename "$file")"
    # if there's only one element left, set `files` to an empty string.
    # this causes us to exit this `while` loop.
    # else, we delete the first "element" of the string from files, and move onto the next.
    if [ "$files" = "$file" ]; then
      files=''
    else
      files="${files#*;}"
    fi
  done
}}

cmd clear_trash %trash-empty

cmd restore_trash ${{
  trash-restore
}}

# define a custom 'delete' command
 cmd delete ${{
     set -f
     printf "$fx\n"
     printf "delete?[y/n]"
     read ans
     [ "$ans" = "y" ] && rm -rf $fx
 }}

# extract the current file with the right command
# (xkcd link: https://xkcd.com/1168/)
cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
        *.tar.gz|*.tgz) tar xzvf $f;;
        *.tar.xz|*.txz) tar xJvf $f;;
        *.zip) unzip $f;;
        *.rar) unrar x $f;;
        *.7z) 7z x $f;;
    esac
}}

# switch git branch
cmd git_branch ${{
    git branch | fzf | xargs git checkout
    pwd_shell=$(pwd)
    lf -remote "send $id updir"
    lf -remote "send $id cd \"$pwd_shell\""
}}

# compress current file or selected files with tar and gunzip
cmd tar ${{
    set -f
    mkdir $1
    cp -r $fx $1
    tar czf $1.tar.gz $1
    rm -rf $1
}}

# compress current file or selected files with zip
cmd zip ${{
    set -f
    mkdir $1
    cp -r $fx $1
    zip -r $1.zip $1
    rm -rf $1
}}

# yank filename without extension
cmd yank-basename-without-extension ${{
    echo "$fx" |
      xargs -r -d '\n' basename -a |
      awk -e '{
        for (i=length($0); i > 0; i--) {
          if (substr($0, i, 1) == ".") {
            if (i == 1) print $0
            else print substr($0, 0, i-1)

            break
          }
        }

        if (i == 0)
          print $0
      }' |
      if [ -n "$fs" ]; then cat; else tr -d '\n'; fi |
      xclip -i -selection clipboard
}}

############################### mapping binding ###########################
# Bindings
# Remove some defaults
map d
map f
map F
map t
map y
map r
map dd cut
# custom f to fzf search directory
map <c-f> $lf -remote "send $id select \"$(fzf)\""
map F $lf -remote "send $id select \"$(find -type d 2>/dev/null | fzf)\""
map . set hidden!
map D trash
map d delete
map M push :mkdir<space>
map U :diskmount
map R reload
# move
map <c-j> push 10j
map <c-k> push 10k
# use enter for shell commands
map <enter> shell
# execute current file (must be executable)
map x $$f
map X extract
# dedicated keys for file opener actions
map o &mimeopen $f
map O $mimeopen --ask $f
# rename
map A rename # at the very end
map I push A<c-a> # at the very beginning
map i push A<a-b><a-b><a-f> # before extension
map a push A<a-b> # after extension
map r bulk-rename
# show 1 pannel or 2 pannel
map w %lf -remote "send $id set ratios 1:2"
map W %lf -remote "send $id set ratios 1:2:3"
# map copy file or file name
map yy copy
map yd $dirname -- "$f" | head -c-1 | xclip -i -selection clipboard # yank dirname
map yp $printf "%s" "$fx" | xclip -selection clipboard # yank path
map yn $basename -a -- $fx | head -c-1 | xclip -i -selection clipboard 
map ye yank-basename-without-extension 
# jump to file
map zz push :z<space>
# Trash Mappings
map tc clear_trash
map tr restore_trash
# Git
map gb :git_branch
map - $~/.config/lf/draw_img.sh "$f"

